
### DOCKERFILE REFERÊNCIA PARA MEUS APPS PYTHON
# Este Dockerfile é um exemplo básico de como criar um container para um aplicativo Python.

# 1 Usar a imagem base do Python, pode ser full, p/ apps, alpine, ou também usar tags "python:3.11-slim-bookworm", também há tipos de windows server core.
# Dependem da politica da empresa.
# Imagem menores são mais seguras, pois tem menos "superficia" de ataque
# Quando usar cada base (regra prática)
#     Quero que funcione com o mínimo de dor de cabeça → python:3.11-slim-bookworm.
#     App usa libs nativas pesadas (numpy, opencv, gdal, shapely) → -slim (nunca Alpine) e instale as libs do SO que o projeto pedir.
#     Imagem mínima e runtime puro → multi-stage para um final “slim”, ou até distroless (só quando já dominar).
#     Preciso de consistência por políticas → padronize 3.x-slim-<distro> e faça rebuilds periódicos para pegar patches.
FROM python:3.10-slim, python:3.11, python:3.12
#------------------------------------------------------------------------

# 2 Boas práticas de ambiente, evitando a escrita de arquivos .pyc e bufferização de saída
# ***** Por padrão, a saída do Python (print, logs) é bufferizada:
#     Significa que ele junta várias linhas na memória antes de realmente escrever na saída (stdout).
#     Isso pode atrasar o aparecimento de logs no terminal.
# Em containers, isso é ruim porque:
#     Logs atrasados dificultam o debug.
#     Ferramentas como docker logs ou o log do CI/CD podem mostrar as mensagens só depois de um tempo. ******
ENV PYTHONDONTWRITEBYTECODE=1
# Garante a saida imediata de logs
ENV PYTHONUNBUFFERED=1
#------------------------------------------------------------------------

# 3 Defina o diretório de trabalho que o container vai rodar, todo os comandos RUN, COPY, ETC. que vier depois daqui vai rodar dentro desta pasta
# Em projetos maiores:
#     /app → código da aplicação
#     /config → arquivos de configuração
#     /data → volumes persistentes
WORKDIR /app
#------------------------------------------------------------------------

# 4 Instalar dependecias do sistema (caso precise) 
# O Dockerfile vem com um imagem básica do python, mas não vem todas as ferramentas e blibliotecas ncessárias para rodar o app.
# algumas bibliotecas do Python precisam de compiladores ou outras dependências do sistema.
# Aqui, instalamos o curl e o gcc que são comuns para muitos projetos python.
# Normalmente se descobre as dependecias em alguns momentos. 
#----Ex . Durante a *instalação* do pip install:
    # "error: command 'gcc' failed: No such file or directory
    #fatal error: some_header.h: No such file or directory"
#----Ou durante a *execução* do app:
    # "ImportError: libsome_library.so.1: cannot open shared object file:
    # oserror(2): No such file or directory"
# Só instalar o que for necessário para o seu projeto.
# Limpa o cache do apt para reduzir o tamanho da imagem
# (O --no-install-recommends evita instalar pacotes extras que não são necessários)
# Agrupar o comando linux no mesmo run para diminuir camadas
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl gcc \ 
&& rm -rf /var/lib/apt/lists/* 
#------------------------------------------------------------------------

# 5 Copia todos os arquivos para o container e instala dependências do Pythona partir do arquvio requirements.txt já provido anteriormente
# ***** parte importante para performace de build *********
# Docker lê o arquivo file de cima pra baixo como layers
# cada layer fica em cache no sistema assosiada ao conteudo que foi usado pra criar
# Se nadar mudar no conteudo de um layer o docker aproveita o layer para o próximo build
# ------- 
#   Passo 1: Copia apenas o requirements.txt.
#   Essa camada só muda se o arquivo requirements.txt mudar.
#   Passo 2: Instala dependências com pip.
#   Essa camada só é refeita se a camada anterior (requirements) mudar.
#   Passo 3: Copia o resto do código.
#
# Não colocar junto das instalações de dependencia acima, se elas estiverem juntas a camada vai fazer todas as instalações de uma vez e uma pequena mudança tem que fazer tudo de novo. O seja desperdiçando cache e tempo.
#     Alterações principalmente no código não invalidam o cache da instalação das dependências.
COPY .requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
#------------------------------------------------------------------------


# 6 Copia projeto para o container
# O primeiro "." significa a origem, aonde eu estou rodando o docker build
# O segundo "." é o destino, dentro da imagem relativo ao WORKDIR definido
# Copia tudo que está na pasta onde o Dockerfile está (exceto arquivos ignorados no .dockerignore) para dentro de /app no container.
# Usar .dockerignore é uma boa prática
COPY . .
#------------------------------------------------------------------------

# 7 Para o caso do streamlit, expondo a porta 8501, que será usada pelo aplicativo dentor do container
EXPOSE 8501
#------------------------------------------------------------------------

# 8 Roda o app
# No caso de [] é um array JSON, cada argumento não passa pelo shell e vão direto para o processo. *melhor pratica*
# Se for direto, da pra usar pipes e variaveis shell por exemplo
CMD ["streamlit", "run", "app.py"]
#------------------------------------------------------------------------

